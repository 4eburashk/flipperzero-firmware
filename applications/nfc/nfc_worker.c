#include "nfc_worker_i.h"
#include <api-hal.h>
#include "nfc_protocols/emv_decoder.h"
#include "nfc_protocols/mifare_ultralight.h"

#define NFC_WORKER_TAG "nfc worker"

/***************************** NFC Worker API *******************************/

NfcWorker* nfc_worker_alloc() {
    NfcWorker* nfc_worker = furi_alloc(sizeof(NfcWorker));
    // Worker thread attributes
    nfc_worker->thread_attr.name = "nfc_worker";
    nfc_worker->thread_attr.stack_size = 8192 * 2;
    nfc_worker->callback = NULL;
    nfc_worker->context = NULL;
    // Initialize rfal
    if(!api_hal_nfc_is_busy()) {
        nfc_worker_change_state(nfc_worker, NfcWorkerStateReady);
    } else {
        nfc_worker_change_state(nfc_worker, NfcWorkerStateBroken);
    }

    return nfc_worker;
}

void nfc_worker_free(NfcWorker* nfc_worker) {
    furi_assert(nfc_worker);
    free(nfc_worker);
}

NfcWorkerState nfc_worker_get_state(NfcWorker* nfc_worker) {
    return nfc_worker->state;
}

void nfc_worker_start(
    NfcWorker* nfc_worker,
    NfcWorkerState state,
    NfcDeviceData* dev_data,
    NfcWorkerCallback callback,
    void* context) {
    furi_assert(nfc_worker);
    furi_assert(dev_data);
    while(nfc_worker->state != NfcWorkerStateReady) {
        osDelay(10);
    }

    nfc_worker->callback = callback;
    nfc_worker->context = context;
    nfc_worker->dev_data = dev_data;
    nfc_worker_change_state(nfc_worker, state);
    nfc_worker->thread = osThreadNew(nfc_worker_task, nfc_worker, &nfc_worker->thread_attr);
}

void nfc_worker_stop(NfcWorker* nfc_worker) {
    furi_assert(nfc_worker);
    if(nfc_worker->state == NfcWorkerStateBroken || nfc_worker->state == NfcWorkerStateReady) {
        return;
    }

    nfc_worker_change_state(nfc_worker, NfcWorkerStateStop);
}

void nfc_worker_change_state(NfcWorker* nfc_worker, NfcWorkerState state) {
    nfc_worker->state = state;
}

/***************************** NFC Worker Thread *******************************/

void nfc_worker_task(void* context) {
    NfcWorker* nfc_worker = context;

    api_hal_power_insomnia_enter();
    api_hal_nfc_exit_sleep();

    if(nfc_worker->state == NfcWorkerStateDetect) {
        nfc_worker_detect(nfc_worker);
    } else if(nfc_worker->state == NfcWorkerStateEmulate) {
        nfc_worker_emulate(nfc_worker);
    } else if(nfc_worker->state == NfcWorkerStateReadEMVApp) {
        nfc_worker_read_emv_app(nfc_worker);
    } else if(nfc_worker->state == NfcWorkerStateReadEMV) {
        nfc_worker_read_emv(nfc_worker);
    } else if(nfc_worker->state == NfcWorkerStateEmulateApdu) {
        nfc_worker_emulate_apdu(nfc_worker);
    } else if(nfc_worker->state == NfcWorkerStateReadMifareUl) {
        nfc_worker_read_mifare_ul(nfc_worker);
    } else if(nfc_worker->state == NfcWorkerStateEmulateMifareUl) {
        nfc_worker_emulate_mifare_ul(nfc_worker);
    } else if(nfc_worker->state == NfcWorkerStateField) {
        nfc_worker_field(nfc_worker);
    }
    api_hal_nfc_deactivate();
    nfc_worker_change_state(nfc_worker, NfcWorkerStateReady);
    api_hal_power_insomnia_exit();
    osThreadExit();
}

void nfc_worker_detect(NfcWorker* nfc_worker) {
    rfalNfcDevice* dev_list;
    rfalNfcDevice* dev;
    uint8_t dev_cnt;
    NfcDeviceCommomData* result = &nfc_worker->dev_data->nfc_data;

    while(nfc_worker->state == NfcWorkerStateDetect) {
        if(api_hal_nfc_detect(&dev_list, &dev_cnt, 1000, true)) {
            // Process first found device
            dev = &dev_list[0];
            result->uid_len = dev->nfcidLen;
            memcpy(result->uid, dev->nfcid, dev->nfcidLen);
            if(dev->type == RFAL_NFC_LISTEN_TYPE_NFCA) {
                result->device = NfcDeviceNfca;
                result->atqa[0] = dev->dev.nfca.sensRes.anticollisionInfo;
                result->atqa[1] = dev->dev.nfca.sensRes.platformInfo;
                result->sak = dev->dev.nfca.selRes.sak;
                if(mf_ul_check_card_type(
                       dev->dev.nfca.sensRes.anticollisionInfo,
                       dev->dev.nfca.sensRes.platformInfo,
                       dev->dev.nfca.selRes.sak)) {
                    result->protocol = NfcDeviceProtocolMifareUl;
                } else if(dev->rfInterface == RFAL_NFC_INTERFACE_ISODEP) {
                    result->protocol = NfcDeviceProtocolEMV;
                } else {
                    result->protocol = NfcDeviceProtocolUnknown;
                }
            } else if(dev->type == RFAL_NFC_LISTEN_TYPE_NFCB) {
                result->device = NfcDeviceNfcb;
            } else if(dev->type == RFAL_NFC_LISTEN_TYPE_NFCF) {
                result->device = NfcDeviceNfcf;
            } else if(dev->type == RFAL_NFC_LISTEN_TYPE_NFCV) {
                result->device = NfcDeviceNfcv;
            }
            // Notify caller and exit
            if(nfc_worker->callback) {
                nfc_worker->callback(nfc_worker->context);
            }
            break;
        }
        osDelay(100);
    }
}

void nfc_worker_emulate(NfcWorker* nfc_worker) {
    NfcDeviceCommomData* data = &nfc_worker->dev_data->nfc_data;
    while(nfc_worker->state == NfcWorkerStateEmulate) {
        if(api_hal_nfc_listen(data->uid, data->uid_len, data->atqa, data->sak, 100)) {
            FURI_LOG_I(NFC_WORKER_TAG, "Reader detected");
        }
        osDelay(10);
    }
}

void nfc_worker_read_emv_app(NfcWorker* nfc_worker) {
    ReturnCode err;
    rfalNfcDevice* dev_list;
    EmvApplication emv_app = {};
    uint8_t dev_cnt = 0;
    uint8_t tx_buff[255] = {};
    uint16_t tx_len = 0;
    uint8_t* rx_buff;
    uint16_t* rx_len;
    NfcDeviceData* result = nfc_worker->dev_data;

    while(nfc_worker->state == NfcWorkerStateReadEMVApp) {
        memset(&emv_app, 0, sizeof(emv_app));
        if(api_hal_nfc_detect(&dev_list, &dev_cnt, 1000, false)) {
            // Card was found. Check that it supports EMV
            if(dev_list[0].rfInterface == RFAL_NFC_INTERFACE_ISODEP) {
                result->nfc_data.uid_len = dev_list[0].dev.nfca.nfcId1Len;
                result->nfc_data.atqa[0] = dev_list[0].dev.nfca.sensRes.anticollisionInfo;
                result->nfc_data.atqa[1] = dev_list[0].dev.nfca.sensRes.platformInfo;
                result->nfc_data.sak = dev_list[0].dev.nfca.selRes.sak;
                memcpy(
                    result->nfc_data.uid, dev_list[0].dev.nfca.nfcId1, result->nfc_data.uid_len);
                result->nfc_data.protocol = NfcDeviceProtocolEMV;

                FURI_LOG_I(NFC_WORKER_TAG, "Send select PPSE command");
                tx_len = emv_prepare_select_ppse(tx_buff);
                err = api_hal_nfc_data_exchange(tx_buff, tx_len, &rx_buff, &rx_len, false);
                if(err != ERR_NONE) {
                    FURI_LOG_E(NFC_WORKER_TAG, "Error during selection PPSE request: %d", err);
                    api_hal_nfc_deactivate();
                    continue;
                }
                FURI_LOG_I(
                    NFC_WORKER_TAG, "Select PPSE response received. Start parsing response");
                if(emv_decode_ppse_response(rx_buff, *rx_len, &emv_app)) {
                    FURI_LOG_I(NFC_WORKER_TAG, "Select PPSE responce parced");
                    // Notify caller and exit
                    result->emv_data.aid_len = emv_app.aid_len;
                    memcpy(result->emv_data.aid, emv_app.aid, emv_app.aid_len);
                    if(nfc_worker->callback) {
                        nfc_worker->callback(nfc_worker->context);
                    }
                    break;
                } else {
                    FURI_LOG_E(NFC_WORKER_TAG, "Can't find pay application");
                    api_hal_nfc_deactivate();
                    continue;
                }
            } else {
                // Can't find EMV card
                FURI_LOG_W(NFC_WORKER_TAG, "Card doesn't support EMV");
                api_hal_nfc_deactivate();
            }
        } else {
            // Can't find EMV card
            FURI_LOG_W(NFC_WORKER_TAG, "Can't find any cards");
            api_hal_nfc_deactivate();
        }
        osDelay(20);
    }
}

void nfc_worker_read_emv(NfcWorker* nfc_worker) {
    ReturnCode err;
    rfalNfcDevice* dev_list;
    EmvApplication emv_app = {};
    uint8_t dev_cnt = 0;
    uint8_t tx_buff[255] = {};
    uint16_t tx_len = 0;
    uint8_t* rx_buff;
    uint16_t* rx_len;
    NfcDeviceData* result = nfc_worker->dev_data;

    while(nfc_worker->state == NfcWorkerStateReadEMV) {
        memset(&emv_app, 0, sizeof(emv_app));
        if(api_hal_nfc_detect(&dev_list, &dev_cnt, 1000, false)) {
            // Card was found. Check that it supports EMV
            if(dev_list[0].rfInterface == RFAL_NFC_INTERFACE_ISODEP) {
                result->nfc_data.uid_len = dev_list[0].dev.nfca.nfcId1Len;
                result->nfc_data.atqa[0] = dev_list[0].dev.nfca.sensRes.anticollisionInfo;
                result->nfc_data.atqa[1] = dev_list[0].dev.nfca.sensRes.platformInfo;
                result->nfc_data.sak = dev_list[0].dev.nfca.selRes.sak;
                memcpy(
                    result->nfc_data.uid, dev_list[0].dev.nfca.nfcId1, result->nfc_data.uid_len);
                result->nfc_data.protocol = NfcDeviceProtocolEMV;

                FURI_LOG_I(NFC_WORKER_TAG, "Send select PPSE command");
                tx_len = emv_prepare_select_ppse(tx_buff);
                err = api_hal_nfc_data_exchange(tx_buff, tx_len, &rx_buff, &rx_len, false);
                if(err != ERR_NONE) {
                    FURI_LOG_E(NFC_WORKER_TAG, "Error during selection PPSE request: %d", err);
                    api_hal_nfc_deactivate();
                    continue;
                }
                FURI_LOG_I(
                    NFC_WORKER_TAG, "Select PPSE response received. Start parsing response");
                if(emv_decode_ppse_response(rx_buff, *rx_len, &emv_app)) {
                    FURI_LOG_I(NFC_WORKER_TAG, "Select PPSE responce parced");
                } else {
                    FURI_LOG_E(NFC_WORKER_TAG, "Can't find pay application");
                    api_hal_nfc_deactivate();
                    continue;
                }
                FURI_LOG_I(NFC_WORKER_TAG, "Starting application ...");
                tx_len = emv_prepare_select_app(tx_buff, &emv_app);
                err = api_hal_nfc_data_exchange(tx_buff, tx_len, &rx_buff, &rx_len, false);
                if(err != ERR_NONE) {
                    FURI_LOG_E(
                        NFC_WORKER_TAG, "Error during application selection request: %d", err);
                    api_hal_nfc_deactivate();
                    continue;
                }
                FURI_LOG_I(
                    NFC_WORKER_TAG,
                    "Select application response received. Start parsing response");
                if(emv_decode_select_app_response(rx_buff, *rx_len, &emv_app)) {
                    FURI_LOG_I(NFC_WORKER_TAG, "Card name: %s", emv_app.name);
                    memcpy(result->emv_data.name, emv_app.name, sizeof(emv_app.name));
                } else {
                    FURI_LOG_E(NFC_WORKER_TAG, "Can't read card name");
                    api_hal_nfc_deactivate();
                    continue;
                }
                FURI_LOG_I(NFC_WORKER_TAG, "Starting Get Processing Options command ...");
                tx_len = emv_prepare_get_proc_opt(tx_buff, &emv_app);
                err = api_hal_nfc_data_exchange(tx_buff, tx_len, &rx_buff, &rx_len, false);
                if(err != ERR_NONE) {
                    FURI_LOG_E(
                        NFC_WORKER_TAG, "Error during Get Processing Options command: %d", err);
                    api_hal_nfc_deactivate();
                    continue;
                }
                if(emv_decode_get_proc_opt(rx_buff, *rx_len, &emv_app)) {
                    FURI_LOG_I(NFC_WORKER_TAG, "Card number parsed");
                    memcpy(
                        result->emv_data.number, emv_app.card_number, sizeof(emv_app.card_number));
                    // Notify caller and exit
                    if(nfc_worker->callback) {
                        nfc_worker->callback(nfc_worker->context);
                    }
                    break;
                } else {
                    // Mastercard doesn't give PAN / card number as GPO response
                    // Iterate over all files found in application
                    bool pan_found = false;
                    for(uint8_t i = 0; (i < emv_app.afl.size) && !pan_found; i += 4) {
                        uint8_t sfi = emv_app.afl.data[i] >> 3;
                        uint8_t record_start = emv_app.afl.data[i + 1];
                        uint8_t record_end = emv_app.afl.data[i + 2];

                        // Iterate over all records in file
                        for(uint8_t record = record_start; record <= record_end; ++record) {
                            tx_len = emv_prepare_read_sfi_record(tx_buff, sfi, record);
                            err = api_hal_nfc_data_exchange(
                                tx_buff, tx_len, &rx_buff, &rx_len, false);
                            if(err != ERR_NONE) {
                                FURI_LOG_E(
                                    NFC_WORKER_TAG,
                                    "Error reading application sfi %d, record %d",
                                    sfi,
                                    record);
                            }
                            if(emv_decode_read_sfi_record(rx_buff, *rx_len, &emv_app)) {
                                pan_found = true;
                                break;
                            }
                        }
                    }
                    if(pan_found) {
                        FURI_LOG_I(NFC_WORKER_TAG, "Card PAN found");
                        memcpy(
                            result->emv_data.number,
                            emv_app.card_number,
                            sizeof(emv_app.card_number));
                        if(emv_app.exp_month) {
                            result->emv_data.exp_mon = emv_app.exp_month;
                            result->emv_data.exp_year = emv_app.exp_year;
                        }
                        // Notify caller and exit
                        if(nfc_worker->callback) {
                            nfc_worker->callback(nfc_worker->context);
                        }
                        break;
                    } else {
                        FURI_LOG_E(NFC_WORKER_TAG, "Can't read card number");
                    }
                    api_hal_nfc_deactivate();
                }
            } else {
                // Can't find EMV card
                FURI_LOG_W(NFC_WORKER_TAG, "Card doesn't support EMV");
                api_hal_nfc_deactivate();
            }
        } else {
            // Can't find EMV card
            FURI_LOG_W(NFC_WORKER_TAG, "Can't find any cards");
            api_hal_nfc_deactivate();
        }
        osDelay(20);
    }
}

void nfc_worker_emulate_apdu(NfcWorker* nfc_worker) {
    ReturnCode err;
    uint8_t tx_buff[255] = {};
    uint16_t tx_len = 0;
    uint8_t* rx_buff;
    uint16_t* rx_len;
    NfcDeviceCommomData params = {
        .uid = {0xCF, 0x72, 0xd4, 0x40},
        .uid_len = 4,
        .atqa = {0x00, 0x04},
        .sak = 0x20,
        .device = NfcDeviceNfca,
        .protocol = NfcDeviceProtocolEMV,
    };
    // Test RX data
    const uint8_t debug_rx[10][103] = {
        {
            0x25, 0x98, 0x77, 0x28, 0xD4, 0x8A, 0x28, 0x7E, 0x9F, 0xEA, 0x2B, 0xB3, 0x0D, 0xF0, 0xBA, 0xF9, 0x63, 0xD1, 0xC6, 0x7B, 0x9B, 0x1A, 0x79, 0xE1, 0x05, 0x5A, 0xFC, 0x8D, 0x80, 0x43, 0xEC, 0xA5, 0xDC, 0xE3, 0x4E, 0x31, 0x6E, 0xF5, 0xB0, 0x0F, 0xE0, 0x5B, 0x42, 0x6D, 0x4C, 0x7C, 0x68, 0xAF, 0x4E, 0x2F, 0x2C, 0x69, 0xC8, 0x25, 0xCB, 0x4E, 0x7F, 0xC8, 0x5B, 0x7F, 0x0D, 0xC7, 0xA5, 0x69, 0xAC, 0x73, 0x9A, 0x9A, 0x69, 0xCA, 0xA9, 0xC9, 0x26, 0x6B, 0x37, 0xF1, 0x67, 0x9F, 0x22, 0x35, 0x4F, 0x4E, 0x1F, 0x97, 0xF2, 0xEA, 0xE5, 0x72, 0xB3, 0xC1, 0xF2, 0xC0, 0x89, 0x98, 0xA9, 0xB5, 0x8B, 0x45, 0x51, 0xF4, 0x8F, 0x7A, 0xBE, 
        },{
            0x36, 0x66, 0x75, 0x28, 0xCD, 0x95, 0x4A, 0x83, 0xE4, 0x18, 0xA2, 0xFB, 0x0B, 0x8D, 0x62, 0xFD, 0x41, 0x24, 0x70, 0x82, 0x2D, 0x09, 0x2C, 0x63, 0x94, 0xF0, 0xB4, 0x09, 0x81, 0x2F, 0x47, 0xB7, 0x95, 0xBC, 0x5F, 0xE3, 0x52, 0x2A, 0x67, 0xB6, 0x42, 0x0A, 0xB3, 0xCD, 0x17, 0x95, 0xCB, 0x58, 0x39, 0x3C, 0x5A, 0x66, 0xC4, 0x87, 0xC9, 0xD8, 0xF7, 0xFD, 0x61, 0x79, 0xAD, 0xA8, 0xB0, 0x43, 0xE4, 0x11, 0xA6, 0x38, 0xBA, 0x8D, 0xEE, 0xFC, 0x17, 0x22, 0x4A, 0x2E, 0xB7, 0x16, 0x07, 0xF0, 0xD1, 0x61, 0xD7, 0x16, 0xE8, 0x21, 0x6E, 0x61, 0x20, 0xCF, 0xDA, 0xCD, 0xF7, 0x0C, 0x90, 0xDD, 0x9C, 0xB7, 0x16, 0x57, 0x45, 0x84, 0x54, 
        },{
            0x5D, 0x27, 0x1F, 0x8B, 0x5E, 0xB4, 0x92, 0x50, 0x87, 0x74, 0xA7, 0x1D, 0xDC, 0x48, 0x8C, 0x3E, 0x68, 0x5C, 0x1A, 0xB5, 0x55, 0xA5, 0xC6, 0x33, 0x42, 0x7E, 0xC8, 0x99, 0x43, 0xCC, 0x6D, 0xA0, 0xF3, 0x8C, 0xAC, 0x53, 0x42, 0xBE, 0x23, 0x49, 0x33, 0xCA, 0x66, 0x90, 0x13, 0xF2, 0xCE, 0xFB, 0xCF, 0x68, 0x31, 0x25, 0x0E, 0xF7, 0xD7, 0x50, 0xF5, 0x20, 0x69, 0x3A, 0xEC, 0xD7, 0xDA, 0xE1, 0x64, 0x07, 0x35, 0x26, 0x46, 0x58, 0x6F, 0xF8, 0xA2, 0xD6, 0x89, 0x35, 0xC9, 0x59, 0xB0, 0x99, 0x41, 0xE2, 0x3E, 0xCF, 0x5A, 0x95, 0x20, 0x51, 0xB5, 0x0A, 0x8B, 0xA3, 0xE1, 0xE5, 0x85, 0xC5, 0x6D, 0x3A, 0xEC, 0xB3, 0x12, 0xDB, 0xAC, 
        },{
            0x34, 0xB2, 0x37, 0x69, 0xFC, 0x10, 0x9A, 0x16, 0xD0, 0xFC, 0x55, 0xA0, 0x57, 0x6A, 0x41, 0x28, 0x21, 0x4B, 0x33, 0xC4, 0xAC, 0x1A, 0x4A, 0x72, 0x87, 0x04, 0xDE, 0xBA, 0x16, 0xBB, 0x67, 0x4A, 0xED, 0x1E, 0x33, 0xEA, 0xAD, 0xCD, 0x81, 0x7F, 0x4A, 0x56, 0x20, 0x22, 0xC0, 0xE0, 0x4A, 0xE1, 0x2C, 0x7E, 0xA6, 0xD8, 0x18, 0x70, 0xCB, 0x9F, 0xF3, 0x2A, 0x5A, 0x0A, 0xE5, 0x41, 0xD3, 0x54, 0xDF, 0x08, 0xBE, 0x8D, 0x55, 0x40, 0x8C, 0x20, 0x96, 0x2D, 0x42, 0x58, 0x0E, 0x8C, 0xB9, 0x3B, 0x8A, 0x61, 0x14, 0xA2, 0x51, 0x5F, 0xC1, 0x46, 0x8A, 0x9B, 0xCF, 0xEF, 0xDD, 0xA4, 0x44, 0x3D, 0x2C, 0x04, 0xCA, 0x81, 0x44, 0x58, 0xA1, 
        },{
            0x5B, 0x85, 0x63, 0x33, 0x93, 0x70, 0xEC, 0x4E, 0xFA, 0x4E, 0xE2, 0x1E, 0x20, 0x42, 0xDF, 0xE5, 0xCC, 0xFB, 0xB5, 0xBD, 0x59, 0x5A, 0x81, 0x96, 0x06, 0x85, 0x61, 0x08, 0x4A, 0x39, 0x29, 0x25, 0xBE, 0x8D, 0x58, 0xD2, 0xFD, 0x45, 0x21, 0xF8, 0x14, 0x04, 0x17, 0x34, 0x47, 0x77, 0x1A, 0x93, 0x73, 0x4F, 0xD0, 0xCC, 0x2A, 0x53, 0x63, 0x30, 0x58, 0x44, 0x38, 0x22, 0x7E, 0x62, 0x47, 0xBC, 0x6F, 0x9F, 0x8F, 0x6D, 0xE5, 0x31, 0xE5, 0xF9, 0x35, 0x7D, 0xAD, 0xFB, 0xF4, 0x47, 0x10, 0xE7, 0x96, 0xE0, 0x34, 0xC0, 0xB3, 0x97, 0x71, 0x0D, 0x5B, 0x29, 0x2F, 0xD9, 0x8B, 0xF6, 0x97, 0x7A, 0x96, 0xA6, 0xE7, 0x7C, 0xD7, 0x4E, 0xF5, 
        },{
            0x8D, 0xCB, 0xA3, 0x09, 0x40, 0x6A, 0x19, 0xA7, 0x02, 0x7A, 0xDB, 0x42, 0x2E, 0xF2, 0xB3, 0xBA, 0x4E, 0xDD, 0x6A, 0xA8, 0xE8, 0x61, 0x40, 0xE3, 0xF7, 0x66, 0xCB, 0xF4, 0xBE, 0x1A, 0x6A, 0x4C, 0x65, 0x8E, 0xD4, 0xA5, 0xF8, 0xEE, 0xCC, 0xFA, 0xE8, 0xA8, 0xBD, 0x17, 0x9B, 0xF0, 0x52, 0x6A, 0x4E, 0xBC, 0x13, 0xB7, 0x1E, 0xD2, 0x9B, 0x16, 0x39, 0xE6, 0x8A, 0x77, 0x02, 0xF5, 0xC3, 0xE6, 0x84, 0x19, 0x0D, 0xFC, 0x08, 0xD9, 0x78, 0x70, 0x83, 0x36, 0x07, 0x9E, 0x27, 0x59, 0x88, 0x76, 0x16, 0x9B, 0x2E, 0x34, 0xED, 0xC9, 0xCA, 0xA7, 0xB0, 0x55, 0x1F, 0x32, 0xCA, 0x63, 0x1A, 0xCE, 0x7C, 0xA6, 0xCC, 0x04, 0x80, 0x45, 0x74, 
        },{
            0x83, 0xFA, 0x7B, 0x23, 0x22, 0xD5, 0xAB, 0x98, 0xEB, 0xC7, 0x46, 0xA0, 0xB5, 0x8F, 0x6B, 0xDC, 0x41, 0x40, 0xFC, 0xF2, 0x8B, 0x60, 0x8C, 0xD9, 0xDC, 0x33, 0x26, 0x60, 0x34, 0xEA, 0xD4, 0xB7, 0xE5, 0xCF, 0x5A, 0x09, 0xA5, 0x86, 0x21, 0x12, 0x4E, 0xE7, 0xB2, 0x83, 0x77, 0x9D, 0x61, 0xB8, 0x5D, 0x5E, 0x2C, 0xE8, 0x3E, 0xB8, 0xC3, 0x9A, 0xEC, 0xE9, 0xFA, 0xA0, 0xD5, 0x4F, 0x58, 0x3B, 0x1F, 0xB3, 0x44, 0x45, 0x3A, 0xE5, 0xD6, 0x08, 0xCD, 0x09, 0x8B, 0xC4, 0xA6, 0x6C, 0x7E, 0x83, 0x4A, 0x2A, 0x6D, 0x88, 0xE2, 0x31, 0xA2, 0x4F, 0x9A, 0x9D, 0xEF, 0xEF, 0x6C, 0xC8, 0x2C, 0x0C, 0x7C, 0xEF, 0x51, 0x36, 0xD5, 0xA7, 0x3E, 
        },{
            0x23, 0xB0, 0x49, 0xE8, 0xD6, 0x36, 0xE6, 0x5A, 0x80, 0x90, 0x47, 0x0A, 0x73, 0xF7, 0xAC, 0x43, 0x93, 0xCA, 0x33, 0x03, 0x37, 0xFB, 0x2F, 0xC2, 0xF7, 0x20, 0x14, 0x2E, 0x75, 0x3B, 0xEB, 0x19, 0x6B, 0xB5, 0x81, 0xC1, 0xEB, 0xE7, 0x9C, 0x6C, 0x78, 0xE3, 0xF5, 0x6B, 0xDC, 0x23, 0xAE, 0xEF, 0xED, 0x62, 0xF2, 0xA4, 0x5E, 0xA2, 0x68, 0xD6, 0x42, 0xFB, 0x84, 0x37, 0xB7, 0xF0, 0xCF, 0x23, 0xA6, 0x51, 0xE5, 0x12, 0xB8, 0x82, 0x7E, 0xB0, 0xE5, 0xF4, 0x1D, 0x42, 0x18, 0xCB, 0x32, 0x85, 0x2E, 0xA5, 0xA9, 0x0D, 0xC7, 0x91, 0xE3, 0x0A, 0x8E, 0xE7, 0xC0, 0xC5, 0xD8, 0x91, 0xE8, 0xFE, 0x62, 0x4E, 0x11, 0x1C, 0x50, 0x10, 0xCC, 
        },{
            0x37, 0x05, 0xE9, 0x79, 0x9C, 0x36, 0x2C, 0x22, 0xE3, 0x51, 0x4B, 0xF0, 0x19, 0xDD, 0x54, 0x23, 0xEB, 0x3D, 0x63, 0xB1, 0x95, 0xF4, 0x9A, 0x95, 0x58, 0x69, 0xA6, 0xF3, 0x39, 0x36, 0x40, 0xEF, 0x3B, 0xAA, 0x6A, 0x57, 0xE0, 0x16, 0xF8, 0xC4, 0x67, 0x45, 0x36, 0x80, 0x23, 0x8A, 0x23, 0x8E, 0x47, 0x86, 0x40, 0xDD, 0xFB, 0x5A, 0x73, 0x54, 0xC3, 0x99, 0xC7, 0x7D, 0xD0, 0x08, 0x6D, 0x8B, 0xB2, 0x57, 0xE3, 0x13, 0x6D, 0xDC, 0x58, 0x54, 0xA1, 0x8E, 0x54, 0x44, 0x98, 0x77, 0xD2, 0xE0, 0x7E, 0x13, 0x3E, 0x7A, 0x6E, 0xB1, 0x4E, 0xB1, 0xCA, 0x16, 0xAE, 0x1B, 0x9D, 0x1D, 0xA7, 0xD0, 0x74, 0x0B, 0xE3, 0xE2, 0xE7, 0x3C, 0xB6, 
        },{
            0x8A, 0x4A, 0x0C, 0x4E, 0xE3, 0x83, 0x22, 0xC4, 0x81, 0x35, 0x03, 0xFB, 0x23, 0x34, 0xC9, 0x55, 0x7E, 0x5F, 0x04, 0x9A, 0xFD, 0x21, 0xC1, 0xCE, 0x16, 0xCC, 0x32, 0x78, 0xB4, 0xEE, 0x2F, 0xBE, 0x39, 0x3B, 0x0E, 0x9C, 0x3F, 0xAF, 0xE0, 0xC0, 0x64, 0xE3, 0xBD, 0x88, 0x97, 0x07, 0x5D, 0x96, 0x67, 0xE0, 0x31, 0x65, 0x82, 0xF2, 0xB3, 0x98, 0xBF, 0x65, 0x11, 0xF3, 0x54, 0x40, 0x33, 0x0E, 0xFB, 0xC0, 0xAA, 0x3B, 0x70, 0x8C, 0xFB, 0xD4, 0xEF, 0x39, 0xDC, 0x08, 0x41, 0xB9, 0x9E, 0xA8, 0x9B, 0x4F, 0x8D, 0x9D, 0xC1, 0xC0, 0x36, 0x01, 0x26, 0xC6, 0xF4, 0x7B, 0x86, 0xA7, 0x89, 0x82, 0xE7, 0x34, 0xBD, 0xD7, 0x40, 0x3A, 0xAD, 
        }
    };
    // Test TX data
    const uint8_t debug_tx[10][103] = {
        {
            0x4F, 0x31, 0x52, 0xD1, 0x08, 0x1B, 0x92, 0x5F, 0xB0, 0x47, 0x5F, 0xC7, 0x18, 0x13, 0x9D, 0xF1, 0x64, 0x88, 0x0C, 0x1E, 0x34, 0xA8, 0x3A, 0x88, 0x4D, 0x24, 0x3C, 0xAD, 0xD2, 0xD3, 0xA0, 0xA2, 0x06, 0xF3, 0x74, 0x8D, 0x0F, 0x08, 0xED, 0x3F, 0xCE, 0xCC, 0x87, 0xE6, 0xDF, 0x25, 0x58, 0xC3, 0x2D, 0x64, 0xE2, 0xE0, 0x8D, 0x1D, 0x69, 0x5A, 0xC0, 0xA5, 0x08, 0x94, 0x7A, 0xA8, 0x37, 0x00, 0x9C, 0x2B, 0x8D, 0x2B, 0x33, 0x7B, 0xEA, 0x02, 0xC7, 0x72, 0x69, 0xA8, 0x17, 0x41, 0x6C, 0x44, 0x26, 0xCE, 0xA5, 0xB3, 0xEC, 0x0F, 0x0E, 0x2D, 0x35, 0x95, 0xC1, 0xAF, 0xBD, 0x78, 0xAF, 0xDA, 0xA4, 0xBC, 0x85, 0xD7, 0xB8, 0x70, 0x5A, 
        },{
            0x80, 0x62, 0x43, 0x29, 0xF8, 0x84, 0x16, 0xBD, 0xAA, 0xE4, 0x63, 0x5E, 0x51, 0x72, 0xEB, 0x7F, 0xA7, 0x01, 0xC0, 0xD6, 0xBF, 0x3A, 0x06, 0x9A, 0xDE, 0xC3, 0x20, 0x36, 0x7C, 0x11, 0x90, 0x7C, 0xF2, 0xD3, 0x26, 0xEC, 0xD8, 0x3C, 0xAA, 0x83, 0xA0, 0x0E, 0x62, 0x72, 0x00, 0x4E, 0xF1, 0x28, 0xCF, 0xB2, 0xFE, 0x8F, 0x6C, 0x06, 0xA9, 0x4B, 0x49, 0xC9, 0x02, 0x45, 0x5A, 0x12, 0xC1, 0x4E, 0x66, 0xE7, 0x3B, 0x3F, 0xA3, 0x65, 0xC2, 0xC4, 0x73, 0x25, 0x37, 0xF2, 0xF3, 0xA8, 0x1B, 0xC3, 0x5B, 0x1B, 0x53, 0x48, 0xA0, 0xFC, 0x13, 0x69, 0x46, 0x15, 0x2E, 0x21, 0x28, 0xEF, 0x6F, 0x8E, 0x58, 0x2A, 0xCD, 0x7B, 0x8F, 0x90, 0x40, 
        },{
            0x82, 0x36, 0xF6, 0x75, 0x2A, 0x9F, 0x11, 0x6D, 0xFB, 0xAB, 0xC0, 0xC3, 0x4C, 0x3D, 0xD6, 0x35, 0x03, 0xEC, 0x63, 0x24, 0x94, 0xD2, 0x13, 0xA2, 0xAA, 0x3D, 0x70, 0xA6, 0xCC, 0x80, 0xE6, 0x4F, 0x36, 0xDE, 0x45, 0x60, 0x7E, 0x56, 0xCD, 0xF9, 0x02, 0x0E, 0xBD, 0xCD, 0xCA, 0x15, 0x82, 0x4E, 0x81, 0xE5, 0xF1, 0x16, 0x38, 0x06, 0xB8, 0x63, 0x43, 0xA8, 0x0A, 0x90, 0x29, 0x70, 0x5F, 0x60, 0x4F, 0xA4, 0x40, 0x4E, 0x7A, 0x8E, 0xC7, 0x7C, 0x1C, 0x06, 0xC9, 0x67, 0x1B, 0x4C, 0xB5, 0x9C, 0xB1, 0x27, 0x32, 0xEA, 0x2D, 0xEA, 0x4E, 0xF0, 0x93, 0xD7, 0x81, 0x3C, 0x48, 0x60, 0x1C, 0x18, 0x06, 0xDC, 0x66, 0x00, 0xEA, 0x2E, 0x7D, 
        },{
            0x07, 0xB3, 0xC6, 0xED, 0xCE, 0x14, 0x23, 0xEA, 0xC5, 0x4B, 0x1D, 0x30, 0xF7, 0x08, 0xFD, 0xE8, 0x1B, 0xD5, 0xE9, 0xD7, 0x1F, 0x4B, 0xF3, 0x37, 0xD0, 0xD0, 0x1D, 0xD0, 0x3B, 0xCA, 0x4E, 0x43, 0x7F, 0x16, 0x31, 0xCD, 0xA9, 0xD4, 0xB9, 0xEE, 0x20, 0xD6, 0x20, 0x18, 0x5F, 0x1E, 0x02, 0xF9, 0x74, 0x6B, 0xD1, 0x13, 0xB6, 0xC6, 0xC9, 0x87, 0x17, 0xE6, 0x59, 0x53, 0x31, 0x27, 0x16, 0xB0, 0xBC, 0xC6, 0xFE, 0x66, 0x9B, 0xB8, 0xD5, 0x3B, 0x0F, 0xF5, 0x54, 0xED, 0x93, 0xD5, 0xE8, 0x87, 0x41, 0xBA, 0x9A, 0x78, 0x01, 0xE3, 0x00, 0x19, 0x4A, 0xD8, 0xEB, 0x7C, 0x01, 0x81, 0xAC, 0x3D, 0x48, 0xAB, 0x24, 0x64, 0xE3, 0xF9, 0x9F, 
        },{
            0x73, 0xEF, 0x73, 0x61, 0x03, 0x49, 0xC9, 0x8B, 0x0B, 0x85, 0x26, 0x83, 0x06, 0x0B, 0x83, 0x9E, 0x55, 0x5D, 0x8A, 0x51, 0xDD, 0x8B, 0xFE, 0x1B, 0xD4, 0x2A, 0x3F, 0xB8, 0x0F, 0x39, 0x58, 0x02, 0xA8, 0x4C, 0x63, 0xAC, 0x95, 0x2E, 0x38, 0xA0, 0x33, 0xDD, 0x24, 0x39, 0x68, 0x28, 0xD8, 0x3E, 0x05, 0xE2, 0x8F, 0xE2, 0x6F, 0x0E, 0xFD, 0xC3, 0x39, 0xBD, 0x7C, 0xC7, 0xF6, 0x54, 0xC9, 0x20, 0xA0, 0xAC, 0xCC, 0xB6, 0x5A, 0x05, 0xD6, 0x8D, 0x62, 0xFB, 0x47, 0xCB, 0xA3, 0x20, 0x0A, 0xA8, 0x82, 0x19, 0x8B, 0xF1, 0x28, 0x09, 0xB5, 0xE0, 0x46, 0xB1, 0xA8, 0x3E, 0x86, 0xF1, 0xDD, 0xA6, 0x9E, 0xAA, 0x5D, 0xF9, 0x2F, 0x35, 0x07, 
        },{
            0x91, 0xB0, 0x4E, 0xDC, 0x54, 0xED, 0xE6, 0x7C, 0x71, 0x01, 0x08, 0xE2, 0xA8, 0x90, 0x19, 0x89, 0xD7, 0xCA, 0xB1, 0x95, 0xD0, 0x23, 0x73, 0x78, 0x41, 0x1E, 0x55, 0xBA, 0xCC, 0x0A, 0xC2, 0x5E, 0xBA, 0x90, 0x3C, 0x8E, 0x7F, 0xA2, 0x0B, 0x70, 0x23, 0x92, 0x53, 0x4B, 0x24, 0x6C, 0xD4, 0x7B, 0xB7, 0x06, 0x90, 0x88, 0xA8, 0x04, 0x80, 0xEA, 0xA1, 0xD6, 0xA5, 0x6E, 0xE0, 0xE7, 0x4C, 0x1C, 0x79, 0x88, 0x2A, 0x78, 0xAB, 0xB5, 0xE8, 0xCE, 0x48, 0xBB, 0x1B, 0xEB, 0x29, 0x6F, 0xE6, 0xE0, 0xF5, 0x77, 0xE8, 0x9E, 0x7B, 0x6A, 0x89, 0x1D, 0xC0, 0xAF, 0x0B, 0x21, 0x97, 0x58, 0xBC, 0x90, 0x60, 0xE7, 0x09, 0x0C, 0x9D, 0x71, 0x5B, 
        },{
            0x65, 0xAD, 0xF5, 0xD1, 0xD6, 0x65, 0xB8, 0x37, 0xDA, 0x31, 0x9F, 0x7A, 0x2C, 0x89, 0x83, 0xC9, 0x4A, 0x33, 0xD4, 0xEB, 0x4B, 0xAC, 0xA8, 0x5B, 0x0E, 0x10, 0xE4, 0x99, 0x2D, 0x56, 0xF4, 0x93, 0x04, 0xEA, 0x65, 0x5A, 0xD0, 0x9D, 0x11, 0xAB, 0xCE, 0xB1, 0xA5, 0xFB, 0x3B, 0x2A, 0x45, 0x06, 0xDC, 0x1A, 0xF1, 0xA7, 0xC7, 0x9A, 0x04, 0x55, 0xAB, 0xE8, 0xEE, 0x58, 0xBE, 0x64, 0xEB, 0x43, 0xCE, 0xD0, 0x1D, 0x9F, 0xEE, 0x2F, 0x4C, 0xBD, 0x60, 0xF1, 0x39, 0x1B, 0x9B, 0xFD, 0x21, 0xF8, 0x19, 0x13, 0xA0, 0x60, 0x2E, 0xA4, 0x35, 0x59, 0x0D, 0x24, 0xB1, 0xCC, 0x08, 0x9E, 0x10, 0xD7, 0xEE, 0xAC, 0x77, 0xDD, 0xDB, 0x43, 0x1C, 
        },{
            0xBB, 0xB5, 0xD4, 0xD7, 0xD0, 0xD3, 0xF8, 0xC9, 0x6C, 0x8C, 0x6B, 0xCC, 0xBA, 0x8F, 0x81, 0x14, 0x9D, 0xA5, 0x45, 0xE9, 0x2E, 0x63, 0x79, 0x06, 0x53, 0x26, 0xFC, 0xB0, 0x03, 0xC0, 0x4C, 0x3E, 0xF5, 0x22, 0x16, 0xC6, 0x75, 0x8F, 0x11, 0x61, 0x1C, 0x7C, 0xAD, 0x56, 0x8B, 0x2F, 0xE9, 0x29, 0x54, 0x2F, 0x13, 0x82, 0x93, 0x8C, 0x08, 0x66, 0xB3, 0x06, 0x96, 0x36, 0x46, 0xE3, 0x74, 0x3C, 0x85, 0x0B, 0x82, 0x7A, 0x9A, 0x93, 0xDB, 0x36, 0x8F, 0x89, 0x8C, 0x1C, 0xB8, 0xF5, 0x45, 0x0D, 0xA4, 0xD8, 0x90, 0x38, 0xE4, 0x98, 0x1E, 0x98, 0x1E, 0xB5, 0x4E, 0xE3, 0x19, 0x43, 0x20, 0x9E, 0x4E, 0x23, 0x19, 0x68, 0x36, 0x74, 0x9E, 
        },{
            0xC6, 0xFD, 0xAA, 0x62, 0xB6, 0xA0, 0x27, 0x43, 0x45, 0x00, 0xD3, 0xFD, 0xE5, 0xEC, 0x9B, 0xFD, 0x8A, 0x51, 0xCC, 0x6F, 0xE9, 0x10, 0x0F, 0x88, 0xDD, 0x32, 0x21, 0x46, 0xE8, 0x95, 0x64, 0xAF, 0x13, 0x0F, 0x12, 0x49, 0x2F, 0xB8, 0x8D, 0xF3, 0xB9, 0xE0, 0x71, 0x1F, 0xCD, 0x0E, 0x9C, 0xD8, 0xDE, 0x69, 0x48, 0xC9, 0xF8, 0xD6, 0xD1, 0xD6, 0x89, 0x73, 0x9C, 0x72, 0x09, 0x80, 0xA1, 0x9C, 0x8F, 0x33, 0xE5, 0x3E, 0xEB, 0x73, 0x33, 0x25, 0x55, 0x24, 0x44, 0xA2, 0x32, 0xE1, 0xFA, 0x12, 0xCA, 0x43, 0x5B, 0x44, 0x9A, 0x2D, 0x9A, 0x24, 0xA0, 0x38, 0x96, 0x2A, 0xB8, 0xB7, 0xC6, 0xC8, 0xEA, 0x2C, 0x86, 0x56, 0xA0, 0x39, 0x7C, 
        },{
            0x75, 0x5E, 0xC0, 0x97, 0x90, 0x22, 0x93, 0x22, 0x6D, 0x56, 0x7D, 0xB1, 0xF0, 0x2B, 0x4C, 0x94, 0xCB, 0x04, 0xAA, 0x75, 0x3D, 0x62, 0x3C, 0x85, 0xCC, 0x69, 0x0C, 0x24, 0x89, 0x46, 0xA0, 0xFE, 0xA4, 0xE0, 0x16, 0xB4, 0x04, 0xA9, 0xD7, 0xF0, 0x01, 0xD4, 0x22, 0x71, 0x7F, 0x6E, 0x07, 0x4C, 0xF2, 0xB1, 0xC1, 0x30, 0x15, 0x7E, 0xB5, 0xE1, 0x67, 0x41, 0x06, 0xF0, 0x87, 0xA6, 0x6F, 0x2C, 0x08, 0x85, 0x61, 0x0C, 0x30, 0xB8, 0x7C, 0xB0, 0x8D, 0x9E, 0x22, 0x0E, 0x8C, 0x29, 0xD9, 0x7F, 0xDB, 0x1B, 0x2F, 0x70, 0x19, 0x64, 0x52, 0x80, 0xA6, 0xD8, 0xF0, 0x2E, 0xFE, 0xDF, 0xDA, 0x07, 0x66, 0x3C, 0x92, 0x16, 0xF4, 0x0F, 0x46, 
        },
    };

    while(nfc_worker->state == NfcWorkerStateEmulateApdu) {
        if(api_hal_nfc_listen(params.uid, params.uid_len, params.atqa, params.sak, 300)) {
            FURI_LOG_I(NFC_WORKER_TAG, "POS terminal detected");
            // Read data from POS terminal
            err = api_hal_nfc_data_exchange(NULL, 0, &rx_buff, &rx_len, false);
            if(err == ERR_NONE) {
                FURI_LOG_I(NFC_WORKER_TAG, "Received Select PPSE");
            } else {
                FURI_LOG_E(NFC_WORKER_TAG, "Error in 1st data exchange: select PPSE");
                api_hal_nfc_deactivate();
                continue;
            }
            FURI_LOG_I(NFC_WORKER_TAG, "Transive SELECT PPSE ANS");
            tx_len = emv_select_ppse_ans(tx_buff);
            err = api_hal_nfc_data_exchange(tx_buff, tx_len, &rx_buff, &rx_len, false);
            if(err == ERR_NONE) {
                FURI_LOG_I(NFC_WORKER_TAG, "Received Select APP");
            } else {
                FURI_LOG_E(NFC_WORKER_TAG, "Error in 2nd data exchange: select APP");
                api_hal_nfc_deactivate();
                continue;
            }

            FURI_LOG_I(NFC_WORKER_TAG, "Transive SELECT APP ANS");
            tx_len = emv_select_app_ans(tx_buff);
            err = api_hal_nfc_data_exchange(tx_buff, tx_len, &rx_buff, &rx_len, false);
            if(err == ERR_NONE) {
                FURI_LOG_I(NFC_WORKER_TAG, "Received PDOL");
            } else {
                FURI_LOG_E(NFC_WORKER_TAG, "Error in 3rd data exchange: receive PDOL");
                api_hal_nfc_deactivate();
                continue;
            }

            FURI_LOG_I(NFC_WORKER_TAG, "Transive PDOL ANS");
            tx_len = emv_get_proc_opt_ans(tx_buff);
            err = api_hal_nfc_data_exchange(tx_buff, tx_len, &rx_buff, &rx_len, false);
            if(err == ERR_NONE) {
                FURI_LOG_I(NFC_WORKER_TAG, "Transive PDOL ANS");
            } else {
                FURI_LOG_E(NFC_WORKER_TAG, "Error in 4rd data exchange: Transive PDOL ANS");
                api_hal_nfc_deactivate();
                continue;
            }

            FURI_LOG_I(NFC_WORKER_TAG, "Start APDU test: expect 10 apdu sequence 103 bytes for each");
            for(uint8_t i = 0; i < 10; i++) {
                if(*rx_len != sizeof(debug_rx[i]) || memcmp(rx_buff, debug_rx[i], sizeof(debug_rx[i]))) {
                    FURI_LOG_E(NFC_WORKER_TAG, "Faild in %d APDU", i);
                    break;
                } else {
                    FURI_LOG_I(NFC_WORKER_TAG, "Correct %d APDU", i);
                    tx_len = sizeof(debug_tx[i]);
                    err = api_hal_nfc_data_exchange(
                        (uint8_t*)debug_tx[i], tx_len, &rx_buff, &rx_len, false);
                    if(err == ERR_NONE) {
                        FURI_LOG_I(NFC_WORKER_TAG, "Transive Debug message %d", i);
                    }
                }
            }
            api_hal_nfc_deactivate();
        } else {
            FURI_LOG_W(NFC_WORKER_TAG, "Can't find reader");
        }
        osDelay(20);
    }
}

void nfc_worker_read_mifare_ul(NfcWorker* nfc_worker) {
    ReturnCode err;
    rfalNfcDevice* dev_list;
    uint8_t dev_cnt = 0;
    uint8_t tx_buff[255] = {};
    uint16_t tx_len = 0;
    uint8_t* rx_buff;
    uint16_t* rx_len;
    MifareUlDevice mf_ul_read;
    NfcDeviceData* result = nfc_worker->dev_data;

    while(nfc_worker->state == NfcWorkerStateReadMifareUl) {
        api_hal_nfc_deactivate();
        memset(&mf_ul_read, 0, sizeof(mf_ul_read));
        if(api_hal_nfc_detect(&dev_list, &dev_cnt, 300, false)) {
            if(dev_list[0].type == RFAL_NFC_LISTEN_TYPE_NFCA &&
               mf_ul_check_card_type(
                   dev_list[0].dev.nfca.sensRes.anticollisionInfo,
                   dev_list[0].dev.nfca.sensRes.platformInfo,
                   dev_list[0].dev.nfca.selRes.sak)) {
                // Get Mifare Ultralight version
                FURI_LOG_I(NFC_WORKER_TAG, "Found Mifare Ultralight tag. Reading tag version");
                tx_len = mf_ul_prepare_get_version(tx_buff);
                err = api_hal_nfc_data_exchange(tx_buff, tx_len, &rx_buff, &rx_len, false);
                if(err == ERR_NONE) {
                    mf_ul_parse_get_version_response(rx_buff, &mf_ul_read);
                    FURI_LOG_I(
                        NFC_WORKER_TAG,
                        "Mifare Ultralight Type: %d, Pages: %d",
                        mf_ul_read.type,
                        mf_ul_read.pages_to_read);
                } else if(err == ERR_TIMEOUT) {
                    FURI_LOG_W(
                        NFC_WORKER_TAG,
                        "Card doesn't respond to GET VERSION command. Setting default read parameters");
                    err = ERR_NONE;
                    mf_ul_set_default_version(&mf_ul_read);
                    // Reinit device
                    api_hal_nfc_deactivate();
                    if(!api_hal_nfc_detect(&dev_list, &dev_cnt, 300, false)) {
                        FURI_LOG_E(NFC_WORKER_TAG, "Lost connection. Restarting search");
                        continue;
                    }
                } else {
                    FURI_LOG_E(
                        NFC_WORKER_TAG,
                        "Error getting Mifare Ultralight version. Error code: %d",
                        err);
                    continue;
                }

                if(mf_ul_read.support_fast_read) {
                    FURI_LOG_I(NFC_WORKER_TAG, "Reading pages ...");
                    tx_len = mf_ul_prepare_fast_read(tx_buff, 0x00, mf_ul_read.pages_to_read - 1);
                    if(api_hal_nfc_data_exchange(tx_buff, tx_len, &rx_buff, &rx_len, false)) {
                        FURI_LOG_E(NFC_WORKER_TAG, "Failed reading pages");
                        continue;
                    } else {
                        mf_ul_parse_fast_read_response(
                            rx_buff, 0x00, mf_ul_read.pages_to_read - 1, &mf_ul_read);
                    }

                    FURI_LOG_I(NFC_WORKER_TAG, "Reading signature ...");
                    tx_len = mf_ul_prepare_read_signature(tx_buff);
                    if(api_hal_nfc_data_exchange(tx_buff, tx_len, &rx_buff, &rx_len, false)) {
                        FURI_LOG_W(NFC_WORKER_TAG, "Failed reading signature");
                        memset(mf_ul_read.data.signature, 0, sizeof(mf_ul_read.data.signature));
                    } else {
                        mf_ul_parse_read_signature_response(rx_buff, &mf_ul_read);
                    }

                    FURI_LOG_I(NFC_WORKER_TAG, "Reading 3 counters ...");
                    for(uint8_t i = 0; i < 3; i++) {
                        tx_len = mf_ul_prepare_read_cnt(tx_buff, i);
                        if(api_hal_nfc_data_exchange(tx_buff, tx_len, &rx_buff, &rx_len, false)) {
                            FURI_LOG_W(NFC_WORKER_TAG, "Failed reading Counter %d", i);
                            mf_ul_read.data.counter[i] = 0;
                        } else {
                            mf_ul_parse_read_cnt_response(rx_buff, i, &mf_ul_read);
                        }
                    }

                    FURI_LOG_I(NFC_WORKER_TAG, "Checking tearing flags ...");
                    for(uint8_t i = 0; i < 3; i++) {
                        tx_len = mf_ul_prepare_check_tearing(tx_buff, i);
                        if(api_hal_nfc_data_exchange(tx_buff, tx_len, &rx_buff, &rx_len, false)) {
                            FURI_LOG_E(NFC_WORKER_TAG, "Error checking tearing flag %d", i);
                            mf_ul_read.data.tearing[i] = MF_UL_TEARING_FLAG_DEFAULT;
                        } else {
                            mf_ul_parse_check_tearing_response(rx_buff, i, &mf_ul_read);
                        }
                    }
                } else {
                    // READ card with READ command (4 pages at a time)
                    for(uint8_t page = 0; page < mf_ul_read.pages_to_read; page += 4) {
                        FURI_LOG_I(NFC_WORKER_TAG, "Reading pages %d - %d ...", page, page + 3);
                        tx_len = mf_ul_prepare_read(tx_buff, page);
                        if(api_hal_nfc_data_exchange(tx_buff, tx_len, &rx_buff, &rx_len, false)) {
                            FURI_LOG_E(
                                NFC_WORKER_TAG, "Read pages %d - %d failed", page, page + 3);
                            continue;
                        } else {
                            mf_ul_parse_read_response(rx_buff, page, &mf_ul_read);
                        }
                    }
                }

                // Fill result data
                result->nfc_data.uid_len = dev_list[0].dev.nfca.nfcId1Len;
                result->nfc_data.atqa[0] = dev_list[0].dev.nfca.sensRes.anticollisionInfo;
                result->nfc_data.atqa[1] = dev_list[0].dev.nfca.sensRes.platformInfo;
                result->nfc_data.sak = dev_list[0].dev.nfca.selRes.sak;
                result->nfc_data.protocol = NfcDeviceProtocolMifareUl;
                memcpy(
                    result->nfc_data.uid, dev_list[0].dev.nfca.nfcId1, result->nfc_data.uid_len);
                result->mf_ul_data = mf_ul_read.data;

                // Notify caller and exit
                if(nfc_worker->callback) {
                    nfc_worker->callback(nfc_worker->context);
                }
                break;
            } else {
                FURI_LOG_W(NFC_WORKER_TAG, "Tag does not support Mifare Ultralight");
            }
        } else {
            FURI_LOG_W(NFC_WORKER_TAG, "Can't find any tags");
        }
        osDelay(100);
    }
}

void nfc_worker_emulate_mifare_ul(NfcWorker* nfc_worker) {
    ReturnCode err;
    uint8_t tx_buff[255] = {};
    uint16_t tx_len = 0;
    uint8_t* rx_buff;
    uint16_t* rx_len;
    NfcDeviceData* data = nfc_worker->dev_data;

    while(nfc_worker->state == NfcWorkerStateEmulateMifareUl) {
        if(api_hal_nfc_listen(
               data->nfc_data.uid,
               data->nfc_data.uid_len,
               data->nfc_data.atqa,
               data->nfc_data.sak,
               1000)) {
            FURI_LOG_I(NFC_WORKER_TAG, "Hello my dudes");
            // Prepare version answer
            tx_len = sizeof(data->mf_ul_data.version);
            memcpy(tx_buff, &data->mf_ul_data.version, tx_len);
            err = api_hal_nfc_data_exchange(tx_buff, tx_len, &rx_buff, &rx_len, false);
            if(err == ERR_NONE) {
                FURI_LOG_I(NFC_WORKER_TAG, "Received 1st message:");
                for(uint16_t i = 0; i < *rx_len; i++) {
                    printf("%02X ", rx_buff[i]);
                }
                printf("\r\n");
            } else {
                FURI_LOG_E(NFC_WORKER_TAG, "Error in 1st data exchange: select PPSE");
                api_hal_nfc_deactivate();
                continue;
            }
        }
        FURI_LOG_W(NFC_WORKER_TAG, "Hello my dudes");
        osDelay(10);
    }
}

void nfc_worker_field(NfcWorker* nfc_worker) {
    api_hal_nfc_field_on();
    while(nfc_worker->state == NfcWorkerStateField) {
        osDelay(50);
    }
    api_hal_nfc_field_off();
}
